---
description: 
globs: 
alwaysApply: false
---
# Railway Testing Rules

## Testing Strategy & Workflow

### Branch-Based Testing Approach
```bash
# Create feature branch for testing
git checkout -b feature/your-feature-name

# Make changes and test locally (optional)
docker compose up

# Push to Railway for testing
git add .
git commit -m "feat: your feature description"
git push origin feature/your-feature-name
```

### Railway Auto-Deployment
- Railway detects git push automatically
- Builds and deploys all services
- Provides unique deployment URLs for testing
- Maintains separate environments per branch

## API Testing on Railway

### Health Check Testing
```bash
# Test backend health endpoint
curl https://your-backend-url.railway.app/api/health

# Expected response
{
  "status": "ok",
  "timestamp": "2025-01-XX...",
  "instance_id": "railway-instance-id"
}
```

### Authentication Testing
```bash
# Test with JWT token
curl -H "Authorization: Bearer YOUR_JWT_TOKEN" \
     https://your-backend-url.railway.app/api/billing/subscription

# Test without token (should return 401)
curl https://your-backend-url.railway.app/api/billing/subscription
```

### API Endpoint Testing Checklist
- [ ] **Health**: `/api/health` returns 200
- [ ] **Authentication**: Auth endpoints work correctly
- [ ] **Billing**: `/api/billing/*` endpoints accessible
- [ ] **Agents**: `/api/agent/*` and `/api/agents/*` endpoints
- [ ] **Threads**: `/api/thread/*` endpoints
- [ ] **Projects**: `/api/project/*` endpoints
- [ ] **Sandbox**: `/api/sandboxes/*` endpoints

## Frontend Testing on Railway

### Browser Testing Workflow
1. **Open Railway Frontend URL**
   - Navigate to your Railway frontend deployment
   - Open Browser DevTools (F12)

2. **Network Tab Verification**
   - Monitor API calls in Network tab
   - Verify all calls use `/api/` prefix
   - Check for 404 errors or failed requests

3. **Console Error Monitoring**
   - Watch for JavaScript errors
   - Look for API-related error messages
   - Verify no CORS issues

### User Flow Testing
```javascript
// Test authentication flow
1. Login/Signup process
2. Dashboard loading
3. Project creation
4. Agent initiation
5. Thread management
6. File uploads/downloads
7. Billing information display
```

### Frontend Testing Checklist
- [ ] **Page Loading**: All pages load without errors
- [ ] **API Communication**: Frontend ↔ Backend communication works
- [ ] **Authentication**: Login/logout flows functional
- [ ] **Dashboard**: Data displays correctly
- [ ] **Agent Features**: Agent creation and interaction
- [ ] **File Operations**: Upload/download functionality
- [ ] **Responsive Design**: Mobile and desktop layouts
- [ ] **Dark/Light Mode**: Theme switching works

## Railway CLI Testing Commands

### Deployment Monitoring
```bash
# Watch deployment logs in real-time
npx @railway/cli logs --service backend --follow
npx @railway/cli logs --service frontend --follow

# Check deployment status
railway status
railway ps

# View recent deployments
npx @railway/cli deployments
```

### Service Health Verification
```bash
# Check all services are running
npx @railway/cli ps

# Get service URLs for testing
npx @railway/cli domain

# View environment variables
npx @railway/cli variables --service backend
npx @railway/cli variables --service frontend
```

### Debugging Commands
```bash
# Connect to service shell for debugging
npx @railway/cli shell --service backend

# Check specific deployment logs
npx @railway/cli logs --deployment DEPLOYMENT_ID

# Redeploy services after fixes
npx @railway/cli redeploy --service backend
npx @railway/cli redeploy --service frontend
npx @railway/cli redeploy --service worker

# Redeploy all services after major changes
npx @railway/cli redeploy --service backend && npx @railway/cli redeploy --service frontend

# Force redeploy with latest code
git push origin main && npx @railway/cli redeploy --service backend
```

## Automated Testing Script

### API Testing Script (Node.js)
```javascript
#!/usr/bin/env node
const https = require('https');

const RAILWAY_BACKEND_URL = process.env.RAILWAY_BACKEND_URL;
const TEST_JWT_TOKEN = process.env.TEST_JWT_TOKEN;

const tests = [
  {
    name: 'Health Check',
    path: '/api/health',
    expectedStatus: 200,
    requiresAuth: false
  },
  {
    name: 'Billing Subscription',
    path: '/api/billing/subscription',
    expectedStatus: [200, 401],
    requiresAuth: true
  },
  {
    name: 'Agent Initiation',
    path: '/api/agent/initiate',
    method: 'POST',
    expectedStatus: [200, 401, 422],
    requiresAuth: true
  }
];

// Run automated tests
async function runTests() {
  for (const test of tests) {
    try {
      const result = await testEndpoint(test.path, {
        method: test.method || 'GET',
        headers: test.requiresAuth && TEST_JWT_TOKEN 
          ? { 'Authorization': `Bearer ${TEST_JWT_TOKEN}` }
          : {}
      });
      
      const expectedStatuses = Array.isArray(test.expectedStatus) 
        ? test.expectedStatus 
        : [test.expectedStatus];
        
      if (expectedStatuses.includes(result.status)) {
        console.log(`✅ ${test.name} - PASS (${result.status})`);
      } else {
        console.log(`❌ ${test.name} - FAIL (${result.status})`);
      }
    } catch (error) {
      console.log(`❌ ${test.name} - ERROR: ${error.message}`);
    }
  }
}
```

### Usage
```bash
# Set environment variables
export RAILWAY_BACKEND_URL=https://your-backend.railway.app
export TEST_JWT_TOKEN=your_jwt_token_here

# Run tests
node test-railway-api.js
```

## Integration Testing

### Frontend-Backend Integration
```javascript
// Test API calls from frontend
const testApiIntegration = async () => {
  try {
    // Test getApiUrl helper usage
    const response = await fetch(getApiUrl('/health'));
    console.log('API Integration:', response.status === 200 ? 'PASS' : 'FAIL');
    
    // Test authenticated endpoints
    const authResponse = await fetch(getApiUrl('/billing/subscription'), {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    console.log('Auth Integration:', authResponse.status === 200 ? 'PASS' : 'FAIL');
  } catch (error) {
    console.error('Integration Test Failed:', error);
  }
};
```

### Database Integration Testing
```bash
# Test Supabase connection from Railway
railway shell --service backend

# Inside backend shell
python -c "
from backend.services.supabase import DBConnection
import asyncio

async def test_db():
    db = DBConnection()
    client = await db.client
    result = await client.table('projects').select('*').limit(1).execute()
    print('DB Connection:', 'PASS' if result.data else 'FAIL')

asyncio.run(test_db())
"
```

## Performance Testing

### Load Testing with curl
```bash
# Test API response times
time curl https://your-backend.railway.app/api/health

# Concurrent request testing
for i in {1..10}; do
  curl -s https://your-backend.railway.app/api/health &
done
wait
```

### Frontend Performance Testing
```javascript
// Measure page load times
window.addEventListener('load', () => {
  const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
  console.log('Page Load Time:', loadTime + 'ms');
});

// Test API response times
const testApiPerformance = async () => {
  const start = performance.now();
  await fetch(getApiUrl('/health'));
  const end = performance.now();
  console.log('API Response Time:', (end - start) + 'ms');
};
```

## Error Testing & Debugging

### Common Error Scenarios
```bash
# Test 404 errors (should not occur with proper getApiUrl usage)
curl https://your-backend.railway.app/billing/subscription  # Missing /api

# Test authentication errors
curl https://your-backend.railway.app/api/billing/subscription  # No auth header

# Test malformed requests
curl -X POST https://your-backend.railway.app/api/agent/initiate  # Missing data
```

### Debugging Failed Tests
```bash
# Check service logs for errors
npx @railway/cli logs --service backend | grep ERROR

# Check for specific error patterns
npx @railway/cli logs --service backend | grep "404" | head -10
npx @railway/cli logs --service backend | grep "No valid authentication" | head -5
npx @railway/cli logs --service frontend | grep -E "(API Error|fetch failed)" | head -10
```

## API Error Testing & Resolution

### 404 Error Testing (Missing /api Prefix)
```bash
# Test for 404 errors - these should NOT occur after fixes
curl -s https://backend-production-xxxxx.up.railway.app/billing/subscription
curl -s -X POST https://backend-production-xxxxx.up.railway.app/agent/initiate

# Expected: 404 errors (wrong URLs without /api prefix)
# These indicate frontend is not using getApiUrl() helper

# Test correct API endpoints - these SHOULD work
curl -s https://backend-production-xxxxx.up.railway.app/api/health
curl -s https://backend-production-xxxxx.up.railway.app/api/billing/subscription
curl -s -X POST https://backend-production-xxxxx.up.railway.app/api/agent/initiate

# Expected responses:
# Health: {"status":"ok","timestamp":"..."}
# Auth endpoints: {"detail":"No valid authentication credentials found"}
```

### Authentication Error Testing
```bash
# Test without authentication (should get 401/403)
curl -s https://backend-production-xxxxx.up.railway.app/api/billing/subscription
curl -s -X POST https://backend-production-xxxxx.up.railway.app/api/agent/initiate

# Test with authentication (get JWT from browser DevTools)
TOKEN="your-jwt-token-here"
curl -H "Authorization: Bearer $TOKEN" \
  https://backend-production-xxxxx.up.railway.app/api/billing/subscription

curl -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -X POST https://backend-production-xxxxx.up.railway.app/api/agent/initiate \
  -d '{"message":"test"}'
```

### Frontend API Error Testing
```javascript
// Test in browser DevTools Console (F12 > Console)

// 1. Test health endpoint (should work without auth)
fetch('/api/health')
  .then(r => r.json())
  .then(data => console.log('Health:', data))
  .catch(err => console.error('Health Error:', err));

// 2. Test billing endpoint (requires auth)
fetch('/api/billing/subscription')
  .then(r => r.json())
  .then(data => console.log('Billing:', data))
  .catch(err => console.error('Billing Error:', err));

// 3. Test agent endpoint (requires auth)
fetch('/api/agent/initiate', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({message: 'test'})
})
  .then(r => r.json())
  .then(data => console.log('Agent:', data))
  .catch(err => console.error('Agent Error:', err));

// 4. Test getApiUrl helper usage
console.log('API URL Helper:', getApiUrl('/health'));
// Should output: https://backend-production-xxxxx.up.railway.app/api/health
```

### Error Monitoring & Real-time Detection
```bash
# Monitor for 404 errors in real-time
npx @railway/cli logs --service backend --follow | grep "404"

# Monitor for authentication errors
npx @railway/cli logs --service backend --follow | grep "No valid authentication"

# Monitor for API errors from frontend
npx @railway/cli logs --service frontend --follow | grep -E "(API Error|fetch failed)"

# Monitor for CORS errors
npx @railway/cli logs --service backend --follow | grep -i "cors"

# Monitor all errors
npx @railway/cli logs --service backend --follow | grep -E "(ERROR|404|500|401|403)"
```

### Error Resolution Workflow
```bash
# 1. Identify the error type from logs
npx @railway/cli logs --service backend | grep "404" | tail -5

# 2. Test the problematic endpoint directly
curl -s https://backend-production-xxxxx.up.railway.app/api/billing/subscription

# 3. Check if frontend is using getApiUrl() helper
grep -r "API_URL" frontend/src/  # Should return no results
grep -r "getApiUrl" frontend/src/  # Should show proper usage

# 4. Fix the code if needed
# Update frontend API calls to use getApiUrl('/endpoint')

# 5. Commit and redeploy
git add . && git commit -m "Fix API routing" && git push origin main
npx @railway/cli redeploy --service frontend

# 6. Verify the fix
curl -s https://backend-production-xxxxx.up.railway.app/api/billing/subscription
npx @railway/cli logs --service backend | grep "404" | tail -5
```

### Post-Deployment Verification
```bash
# Complete verification checklist after each deployment

# 1. Check deployment status
npx @railway/cli status

# 2. Test health endpoints
curl -s https://backend-production-xxxxx.up.railway.app/api/health
curl -s https://frontend-production-xxxxx.up.railway.app/

# 3. Verify no 404 errors in recent logs
npx @railway/cli logs --service backend | grep "404" | tail -5

# 4. Test critical API endpoints
curl -s https://backend-production-xxxxx.up.railway.app/api/billing/subscription
curl -s -X POST https://backend-production-xxxxx.up.railway.app/api/agent/initiate

# 5. Check frontend can reach backend (open in browser)
# - Open frontend URL
# - Check DevTools Network tab
# - Verify API calls use correct URLs with /api prefix

# 6. Monitor for new errors
npx @railway/cli logs --service backend --follow | grep -E "(ERROR|404|500)" &
npx @railway/cli logs --service frontend --follow | grep "API Error" &
```

### Common Error Patterns & Solutions

#### Pattern 1: 404 Errors
```bash
# Log pattern: GET /billing/subscription HTTP/1.1" 404
# Problem: Frontend not using /api prefix
# Solution: Use getApiUrl('/billing/subscription') instead of direct URL
```

#### Pattern 2: Authentication Errors  
```bash
# Log pattern: {"detail":"No valid authentication credentials found"}
# Problem: Missing or invalid JWT token
# Solution: Check token in browser DevTools, verify auth flow
```

#### Pattern 3: CORS Errors
```bash
# Log pattern: CORS policy error
# Problem: Frontend domain not in CORS_ORIGINS
# Solution: Update CORS_ORIGINS environment variable
```

#### Pattern 4: Network Errors
```bash
# Log pattern: Connection refused, timeout
# Problem: Service communication issues
# Solution: Check Railway internal networking, verify service URLs
```

# Verify environment variables
railway variables --service backend | grep -E "(SUPABASE|API)"

# Test service connectivity
railway shell --service backend
ping redis
ping rabbitmq
```

## Testing Environment Management

### Environment Variable Testing
```bash
# Verify all required variables are set
railway variables --service backend | grep -E "(SUPABASE_URL|ANTHROPIC_API_KEY|OPENAI_API_KEY)"

# Test variable interpolation
railway variables --service backend | grep -E "(REDIS_HOST|RABBITMQ_HOST)"
```

### Service Communication Testing
```bash
# Test internal service communication
railway shell --service backend

# Inside backend shell
curl http://$REDIS_HOST:$REDIS_PORT/ping
curl http://$RABBITMQ_HOST:$RABBITMQ_PORT/api/overview
```

## Regression Testing

### API Regression Tests
```javascript
const regressionTests = [
  // Test previously fixed 404 errors
  { endpoint: '/api/billing/subscription', description: 'Billing API fixed' },
  { endpoint: '/api/agents/123', description: 'Agent API fixed' },
  { endpoint: '/api/agent/initiate', description: 'Agent initiation fixed' },
  { endpoint: '/api/health', description: 'Health check working' }
];

// Run regression test suite
regressionTests.forEach(async (test) => {
  const response = await fetch(getApiUrl(test.endpoint));
  console.log(`${test.description}: ${response.status !== 404 ? 'PASS' : 'FAIL'}`);
});
```

### Frontend Regression Tests
```javascript
// Test for common frontend issues
const frontendRegressionTests = [
  () => document.querySelector('[data-testid="dashboard"]') !== null,
  () => !document.querySelector('.error-404'),
  () => fetch(getApiUrl('/health')).then(r => r.ok),
  () => localStorage.getItem('supabase.auth.token') !== null
];

frontendRegressionTests.forEach((test, index) => {
  try {
    const result = test();
    console.log(`Frontend Test ${index + 1}: ${result ? 'PASS' : 'FAIL'}`);
  } catch (error) {
    console.log(`Frontend Test ${index + 1}: ERROR - ${error.message}`);
  }
});
```

## Production Testing Checklist

### Pre-Production Testing
- [ ] All API endpoints return expected status codes
- [ ] Authentication flows work correctly
- [ ] Database connections established
- [ ] External API integrations functional
- [ ] File upload/download operations work
- [ ] Background tasks processing correctly
- [ ] Error handling working as expected

### Post-Deployment Verification
- [ ] Health checks passing for all services
- [ ] Frontend loads without JavaScript errors
- [ ] API calls use correct URLs with `/api` prefix
- [ ] User authentication and authorization working
- [ ] Billing and subscription features functional
- [ ] Agent creation and interaction working
- [ ] Real-time features (streaming) operational

### Performance Verification
- [ ] API response times under 2 seconds
- [ ] Frontend initial load under 3 seconds
- [ ] Database queries optimized
- [ ] Redis caching effective
- [ ] No memory leaks in long-running processes

## Continuous Testing Strategy

### Automated Testing Pipeline
```yaml
# Example GitHub Actions for Railway testing
name: Railway Testing
on:
  push:
    branches: [feature/*]

jobs:
  test-railway-deployment:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Test API Endpoints
        run: |
          npm install -g @railway/cli
          railway login --token ${{ secrets.RAILWAY_TOKEN }}
          node test-railway-api.js
```

### Manual Testing Schedule
- **Daily**: Health checks and basic functionality
- **Weekly**: Full regression test suite
- **Pre-Release**: Comprehensive integration testing
- **Post-Deployment**: Production verification checklist

## Testing Best Practices

### Test Data Management
- Use test-specific data that doesn't affect production
- Clean up test data after testing sessions
- Use separate test accounts for authentication testing
- Maintain test data consistency across environments

### Test Documentation
- Document all test cases and expected outcomes
- Maintain test result logs for debugging
- Track performance metrics over time
- Record and analyze failure patterns

### Collaboration Testing
- Share test results with team members
- Use Railway's collaboration features for team testing
- Coordinate testing schedules to avoid conflicts
- Maintain shared testing documentation and procedures






